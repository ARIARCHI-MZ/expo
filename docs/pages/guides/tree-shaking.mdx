---
title: Tree shaking and code removal
sidebar_title: Tree shaking
description: Learn about how Expo CLI optimizes production JavaScript bundles.
---

import { Step } from '~/ui/components/Step';
import { Terminal } from '~/ui/components/Snippet';
import { Tab, Tabs, TabsGroup } from '~/ui/components/Tabs';

Tree shaking (sometimes refered to as "dead code removal") is a technique that removes unused code from the production bundle. Expo CLI employs a couple different techniques, including [minification](/guides/minify), for removing unused code from a production bundle to improve startup time.

## Platform shaking

Expo CLI bundles apps individually for each platform (iOS, Android, web). This means that code that is only used on one platform will be removed from the other platforms. We call this technique "platform shaking".

Specifically, any code that is used conditionally based on the `Platform` module from `react-native` will be removed from the other platforms. Note that `Platform.select` and `Platform.OS` will only be removed if they're clearly imported from `react-native` on a per-file basis, if a module re-exports them, then they will not be removed.

For example, consider the following transformation input:

```js Input
import { Platform } from 'react-native';

if (Platform.OS === 'ios') {
  console.log('Hello on iOS');
}
```

The production bundle will remove the conditional based on the output platform:

```js Output (iOS)
console.log('Hello on iOS');
```

```js Output (Android)
/* @hide Empty on Android */
```

### Enabling platform shaking

<Tabs>
  <Tab label="Expo SDK 50 and greater">
  
    Platform shaking is enabled by default in Expo SDK 50 and only applied when bundling for production.

  </Tab>
  <Tab label="Expo SDK 49 and lower">

    To remove code based on the `Platform` module from `react-native`, you need to add the following to your **metro.config.js**:

    ```js metro.config.js
    const { getDefaultConfig } = require('expo/metro-config');

    const config = getDefaultConfig(__dirname);

    config.transformer.getTransformOptions = async () => ({
      transform: {
        /* @info this feature is experimental and may cause other issues. */
        experimentalImportSupport: true,
        /* @end */
      },
    });

    module.exports = config;
    ```

    And configure the `babel.config.js` to preserve import/export syntax:

    ```js babel.config.js
    module.exports = function (api) {
      api.cache(true);
      /* @info */
      const disableImportExportTransform = true;
      /* @end */
      return {
        presets: [
          [
            'babel-preset-expo',
            {
              native: {
                /* @info */
                disableImportExportTransform,
                /* @end */
              },
              web: {
                /* @info */
                disableImportExportTransform,
                /* @end */
              },
            },
          ],
        ],
      };
    };
    ```
  </Tab>
</Tabs>

## Removing development-only code

You may have code in your project that is intended to help your development process and should be removed during the production bundle. For these cases, use the `process.env.NODE_ENV` environment variable or the non-standard `__DEV__` global boolean. For example:

```js Input
if (process.env.NODE_ENV === 'development') {
  console.log('Hello in development');
}

if (__DEV__) {
  console.log('Another development-only conditional...');
}
```

```js Output (production)
/* @hide Empty file */
```

For speed purposes, Expo CLI will only perform code elimination in production builds, meaning the conditionals will be kept in development builds.

## Custom code removal

Starting in Expo SDK 50, `EXPO_PUBLIC_` environment variables are inlined before minification. This means you can use them to remove code from the production bundle. For example:

```js .env
EXPO_PUBLIC_DISABLE_FEATURE=true
```

```js Input
if (!process.env.EXPO_PUBLIC_DISABLE_FEATURE) {
  console.log('Hello from the feature!');
}
```

```js Post babel-preset-expo
if (!"true") {
  console.log('Hello from the feature!');
}
```

```js Post minifier
// Empty file
```

This does not apply to server code as environment variables are not inlined in server bundles.

## Removing unused imports and exports

As of Expo SDK 50, unused imports and exports are not removed from the production bundle. We plan to add this feature to all platforms in a future release.

## Barrel files

Barrel files are files that export all of the modules in a directory. They are used to make importing modules easier. For example, component-based icon libraries often do this.

```js node_modules/<example library>/index.js
export { default as IconA } from './IconA';
export { default as IconB } from './IconB';
export { default as IconC } from './IconC';
```

If you're looking to reduce bundle size, identify which of these modules you're using and try to import them directly. 

The ease of use you get out of quickly importing files is important, especially if you don't have a minimum-viable product/project released yet, so avoid over-optimizing on "use no barrel files" too early in the development-cycle.

As of Expo SDK 50, there are no built-in bundler optimizations for barrel files.

## React Native web imports

`babel-preset-expo` provides a built-in optimization for the `react-native-web` barrel file, if you import `react-native` directly using ESM, then the barrel file will be removed from the production bundle.
    
```js Input
import { View, Image } from 'react-native';
```

```js Output (web)
import View from 'react-native-web/dist/exports/View';
import Image from 'react-native-web/dist/exports/Image';
```

If you import `react-native` using requires, then the barrel file will be left as-is in the production bundle.

```js
const { View, Image } = require('react-native');
```

```js Output (web)
const { View, Image } = require('react-native-web');
```

