---
title: Authentication in Expo Router
sidebar_title: Authentication
description: How to protect routes with Expo Router.
hideTOC: true
---

import { FileTree } from '~/ui/components/FileTree';

It's common to restrict certain routes to users who are not authenticated. This can be achieved in a very organized way by using React Context and Route Groups.

Consider the following project:

<FileTree
  files={[
    'app/_layout.js',
    'app/index.js',
    'app/(auth)/sign-in.js',
    'app/(protected)/_layout.js',
    'app/(protected)/protected-route.js',
  ]}
/>

First, we'll setup a [React Context provider](https://react.dev/reference/react/createContext) that we can use to protect routes. This provider will use a mock implementation, you can replace it with your own [authentication provider](/guides/authentication/).

```jsx context/auth.js
import { router, useSegments } from 'expo-router';
import React from 'react';

const AuthContext = React.createContext(null);

// This hook can be used to access the user info.
export function useAuth() {
  return React.useContext(AuthContext);
}

export function Provider(props) {
  const [user, setAuth] = React.useState(null);

  return (
    <AuthContext.Provider
      value={{
        signIn: () => setAuth({}),
        signOut: () => setAuth(null),
        user,
      }}>
      {props.children}
    </AuthContext.Provider>
  );
}

// This High Order Component (HOC) can be used to wrap routes or _layouts to ensure the user is authenticated.
export function privateRoute<P extends {}, T>(
  Component: ComponentType<P>,
  redirectHref: Href<T>
) {
  return forwardRef<"ref" extends keyof P ? P["ref"] : unknown, P>(function (
    props,
    ref
  ) {
    const { user } = useAuth();

    if (!user) {
      return <Redirect href={redirectHref} />;
    }

    return <Component ref={ref} {...props} />;
  });
}
```

Now we can use this context to control the access to the routes, we'll do this by using a Layout Route that wraps all the screens which require authentication.

```jsx app/_layout.js
import { Slot } from 'expo-router';
import { Provider } from '../context/auth';

export default function Root() {
  return (
    // Setup the auth context and render our layout inside of it.
    <Provider>
      <Slot />
    </Provider>
  );
}
```

Now we can create our `(auth)` group which is unprotected, this screen can toggle the authentication using `signIn()`.

```jsx app/(auth)/sign-in.js
import { Text, View } from 'react-native';
import { useAuth } from '../../context/auth';

export default function SignIn() {
  const { signIn } = useAuth();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text onPress={() => signIn()}>Sign In</Text>
    </View>
  );
}
```

Now we can create our `(protected)` group which ensures the user is authenticated before rendering the component.

```jsx app/(protected)/_layout.js
import { Text, View } from 'react-native';
import { Slot } from 'expo-router';
import { protectedRoute } from '../../context/auth';

export default protectedRoute(Slot, '/sign-in');
```

```jsx app/(protected)/private-route.js
import { Text, View } from 'react-native';

export default function PrivateRoute() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text>You must be authenticated to see this route</Text>
    </View>
  );
}
```

And finally we'll implement an authenticated screen which can sign out.

```jsx app/index.js
import { Text, View } from 'react-native';

import { useAuth } from '../context/auth';

export default function Index() {
  const { signOut } = useAuth();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text onPress={() => signOut()}>Sign Out</Text>
    </View>
  );
}
```

Now if the authentication state changes globally, the user will be redirected to the appropriate route.
