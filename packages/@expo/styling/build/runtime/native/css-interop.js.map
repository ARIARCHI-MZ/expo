{"version":3,"file":"css-interop.js","sourceRoot":"","sources":["../../../src/runtime/native/css-interop.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, { ComponentType, useMemo, useEffect, useReducer, useState } from 'react';\nimport { View, Pressable } from 'react-native';\n\nimport { ContainerRuntime, InteropMeta, StyleMeta } from '../../types';\nimport { AnimationInterop } from './animations';\nimport { flattenStyle } from './flatten-style';\nimport { ContainerContext, VariableContext, globalStyles, styleMetaMap } from './globals';\nimport { useInteractionHandlers, useInteractionSignals } from './interaction';\nimport { useComputation } from './signals';\nimport { StyleSheet } from './stylesheet';\n\ntype CSSInteropWrapperProps = {\n  __component: ComponentType<any>;\n  __styleKeys: string[];\n  __experimental: boolean;\n} & Record<string, any>;\n\n/**\n * This is the default implementation of the CSS interop function. It is used to add CSS styles to React Native components.\n * @param jsx The JSX function that should be used to create the React elements.\n * @param type The React component type that should be rendered.\n * @param props The props object that should be passed to the component.\n * @param key The optional key to use for the component.\n * @param experimental Indicates whether this component should use experimental features\n * @returns The element rendered via the suppled JSX function\n */\nexport function defaultCSSInterop(\n  jsx: Function,\n  type: ComponentType<any>,\n  { ...props }: any,\n  key: string,\n  experimental = false\n) {\n  // This sets the component type and specifies the style keys that should be used.\n  props.__component = type;\n  props.__styleKeys = ['style'];\n  props.__experimental = experimental;\n\n  /**\n   * If the development environment is enabled, we should use the DevOnlyCSSInteropWrapper to wrap every component.\n   * This wrapper subscribes to StyleSheet.register, so it can handle hot reloading of styles.\n   */\n  if (__DEV__) {\n    return jsx(DevOnlyCSSInteropWrapper, props, key);\n  }\n\n  // Rewrite the className prop to a style object.\n  props = classNameToStyle(props);\n\n  // If the styles are dynamic, we need to wrap the component with the CSSInteropWrapper to handle style updates.\n  return areStylesDynamic(props.style) ? jsx(CSSInteropWrapper, props, key) : jsx(type, props, key);\n}\n\n/**\n * This is the DevOnlyCSSInteropWrapper that should be used in development environments to handle async style updates.\n * It subscribes to StyleSheet.register, so it can handle style changes that may occur asynchronously.\n */\nconst DevOnlyCSSInteropWrapper = React.forwardRef(function DevOnlyCSSInteropWrapper(\n  { __component: Component, __styleKeys, __experimental, ...props }: CSSInteropWrapperProps,\n  ref\n) {\n  // This uses a reducer and the useEffect hook to subscribe to StyleSheet.register.\n  const [, render] = useReducer(rerenderReducer, 0);\n  useEffect(() => StyleSheet.__subscribe(render), []);\n\n  // This applies the styles using the classNameToStyle function, which returns the style object.\n  props = classNameToStyle(props);\n\n  // If the styles are dynamic, we need to wrap the component with the CSSInteropWrapper to handle style updates.\n  return areStylesDynamic(props.style) ? (\n    <CSSInteropWrapper\n      {...props}\n      ref={ref}\n      __component={Component}\n      __styleKeys={__styleKeys}\n      __skipCssInterop\n      __experimental={__experimental}\n    />\n  ) : (\n    <Component {...props} ref={ref} __skipCssInterop />\n  );\n});\n\n/**\n * This component is a wrapper that handles the styling interop between React Native and CSS functionality\n *\n * @remarks\n * The CSSInteropWrapper function has an internal state, interopMeta, which holds information about the styling props,\n * like if it's animated, if it requires a layout listener, if it has inline containers, etc. When a style prop changes, the component\n * calculates the new style and meta again using a helper function called flattenStyle.\n *\n * @param __component - Component to be rendered\n * @param __styleKeys - List of keys with the style props that need to be computed\n * @param __experimental - Flag indicating if should we should advanced featuers\n * @param $props - Any other props to be passed to the component\n * @param ref - Ref to the component\n */\nconst CSSInteropWrapper = React.forwardRef(function CSSInteropWrapper(\n  {\n    __component: Component,\n    __styleKeys,\n    __experimental: experimental,\n    ...$props\n  }: CSSInteropWrapperProps,\n  ref\n) {\n  const [, rerender] = React.useReducer(rerenderReducer, 0);\n  const inheritedVariables = React.useContext(VariableContext);\n  const inheritedContainers = React.useContext(ContainerContext);\n  const interaction = useInteractionSignals();\n\n  /**\n   * The purpose of interopMeta is to reduce the number of operations performed in the render function.\n   * The meta is entirely derived from the computed styles, so we only need to calculate it when a style changes.\n   *\n   * The interopMeta object holds information about the styling props, like if it's animated, if it requires layout,\n   * if it has inline containers, etc.\n   *\n   * The object is updated using the derived state pattern. The computation is done in the for loop below and\n   * is stored in a variable $interopMeta. After that, the component checks if $interopMeta is different from interopMeta\n   * to update the state.\n   */\n  const [$interopMeta, setInteropMeta] = useState<InteropMeta>(initialMeta);\n  let interopMeta = $interopMeta;\n\n  for (const key of __styleKeys) {\n    /**\n     * Create a computation that will flatten the style object.\n     * Any signals read while the computation is running will be subscribed to.\n     *\n     * useComputation handles the reactivity/memoization\n     * flattenStyle handles converting the schema to a style object and collecting the metadata\n     */\n    /* eslint-disable react-hooks/rules-of-hooks -- __styleKeys is immutable */\n    const style = useComputation(\n      () => {\n        return flattenStyle($props[key], {\n          interaction,\n          variables: inheritedVariables,\n          containers: inheritedContainers,\n        });\n      },\n      [$props[key], inheritedVariables, inheritedContainers],\n      rerender\n    );\n    /* eslint-enable react-hooks/rules-of-hooks */\n\n    /*\n     * Recalculate the interop meta when a style change occurs, due to a style update.\n     * Rather than comparing the changes, we recalculate the entire meta.\n     * To update the interop meta, we modify the `styledProps` and `styledPropsMeta` properties,\n     * which will be flattened later.\n     */\n    if (interopMeta.styledProps[key] !== style) {\n      const meta = styleMetaMap.get(style) ?? defaultMeta;\n\n      interopMeta = {\n        ...interopMeta,\n        styledProps: { ...interopMeta.styledProps, [key]: style },\n        styledPropsMeta: {\n          ...interopMeta.styledPropsMeta,\n          [key]: {\n            animated: Boolean(meta.animations),\n            transition: Boolean(meta.transition),\n            requiresLayout: Boolean(meta.requiresLayout),\n            variables: meta.variables,\n            containers: meta.container?.names,\n            hasActive: meta.pseudoClasses?.active,\n            hasHover: meta.pseudoClasses?.hover,\n            hasFocus: meta.pseudoClasses?.focus,\n          },\n        },\n      };\n    }\n  }\n\n  // interopMeta has changed since last render (or it's the first render)\n  // Recalculate the derived attributes and rerender\n  if (interopMeta !== $interopMeta) {\n    let hasInlineVariables = false;\n    let hasInlineContainers = false;\n    let requiresLayout = false;\n    let hasActive: boolean | undefined = false;\n    let hasHover: boolean | undefined = false;\n    let hasFocus: boolean | undefined = false;\n\n    const variables = {};\n    const containers: Record<string, ContainerRuntime> = {};\n    const animatedProps = new Set<string>();\n    const transitionProps = new Set<string>();\n\n    for (const key of __styleKeys) {\n      const meta = interopMeta.styledPropsMeta[key];\n\n      Object.assign(variables, meta.variables);\n\n      if (meta.variables) hasInlineVariables = true;\n      if (meta.animated) animatedProps.add(key);\n      if (meta.transition) transitionProps.add(key);\n      if (meta.containers) {\n        hasInlineContainers = true;\n        const runtime: ContainerRuntime = {\n          type: 'normal',\n          interaction,\n          style: interopMeta.styledProps[key],\n        };\n\n        containers.__default = runtime;\n        for (const name of meta.containers) {\n          containers[name] = runtime;\n        }\n      }\n\n      requiresLayout ||= hasInlineContainers || meta.requiresLayout;\n      hasActive ||= hasInlineContainers || meta.hasActive;\n      hasHover ||= hasInlineContainers || meta.hasHover;\n      hasFocus ||= hasInlineContainers || meta.hasFocus;\n    }\n\n    let animationInteropKey: string | undefined = undefined;\n    if (animatedProps.size > 0 || transitionProps.size > 0) {\n      animationInteropKey = [...animatedProps, ...transitionProps].join(':');\n    }\n\n    interopMeta = {\n      ...interopMeta,\n      variables,\n      containers,\n      animatedProps,\n      transitionProps,\n      requiresLayout,\n      hasInlineVariables,\n      hasInlineContainers,\n      animationInteropKey,\n      hasActive,\n      hasHover,\n      hasFocus,\n    };\n\n    setInteropMeta(interopMeta);\n  }\n\n  if (\n    Component === View &&\n    (interopMeta.hasActive || interopMeta.hasHover || interopMeta.hasFocus)\n  ) {\n    Component = Pressable;\n  }\n\n  const variables = useMemo(\n    () => Object.assign({}, inheritedVariables, $interopMeta.variables),\n    [inheritedVariables, $interopMeta.variables]\n  );\n\n  const containers = useMemo(\n    () => Object.assign({}, inheritedContainers, $interopMeta.containers),\n    [inheritedContainers, $interopMeta.containers]\n  );\n\n  // This doesn't need to be memoized as it's values will be spread across the component\n  const props: Record<string, any> = {\n    ...$props,\n    ...interopMeta.styledProps,\n    ...useInteractionHandlers($props, interaction, interopMeta),\n  };\n\n  let children: JSX.Element = props.children;\n\n  if ($interopMeta.hasInlineVariables) {\n    children = <VariableContext.Provider value={variables}>{children}</VariableContext.Provider>;\n  }\n\n  if ($interopMeta.hasInlineContainers) {\n    children = <ContainerContext.Provider value={containers}>{children}</ContainerContext.Provider>;\n  }\n\n  if (experimental && $interopMeta.animationInteropKey) {\n    return (\n      <AnimationInterop\n        {...props}\n        ref={ref}\n        key={$interopMeta.animationInteropKey}\n        __component={Component}\n        __variables={variables}\n        __containers={inheritedContainers}\n        __interaction={interaction}\n        __interopMeta={$interopMeta}\n        __skipCssInterop>\n        {children}\n      </AnimationInterop>\n    );\n  } else {\n    return (\n      <Component {...props} ref={ref} __skipCssInterop>\n        {children}\n      </Component>\n    );\n  }\n});\n\n/**\n * Maps each class name in the `className` property of the input object\n * to its corresponding global style object and combines the resulting\n * array of styles with any existing styles in the `style` property of\n * the input object.\n *\n * @param props - An object that may contain a `className` property and a `style` property\n * @returns The modified input object with updated `style` property\n */\nfunction classNameToStyle({ className, ...props }: Record<string, unknown>) {\n  if (typeof className === 'string') {\n    // Split className string into an array of class names, then map each class\n    // name to its corresponding global style object, if one exists.\n    const classNameStyle = className.split(/\\s+/).map((s) => globalStyles.get(s));\n\n    // Combine the resulting array of styles with any existing styles in the `style` property\n    // of the input object.\n    props.style = Array.isArray(props.style)\n      ? [...classNameStyle, ...props.style]\n      : props.style\n      ? [...classNameStyle, props.style]\n      : classNameStyle;\n\n    // If there is only one style in the resulting array, replace the array with that single style.\n    if (Array.isArray(props.style) && props.style.length <= 1) {\n      props.style = props.style[0];\n    }\n  }\n\n  return props;\n}\n\n/**\n * Determines whether a style object or array of style objects contains dynamic styles.\n * @param style The style object or array of style objects to check.\n * @returns True if the style object or array contains dynamic styles; otherwise, false.\n */\nfunction areStylesDynamic(style: any): boolean {\n  if (!style) return false; // If there is no style, it can't be dynamic.\n  if (styleMetaMap.has(style)) return true; // If it's already tagged, it's dynamic.\n\n  // If we have an array of styles, check each one.\n  // We can then tag the array so we don't have to check it again.\n  if (Array.isArray(style) && style.some(areStylesDynamic)) {\n    styleMetaMap.set(style, {}); // Tag the array so we don't have to check it again.\n    return true;\n  }\n\n  return false;\n}\n\n/* Micro optimizations. Save these externally so they are not recreated every render  */\nconst rerenderReducer = (acc: number) => acc + 1;\nconst defaultMeta: StyleMeta = { container: { names: [], type: 'normal' } };\nconst initialMeta: InteropMeta = {\n  styledProps: {},\n  styledPropsMeta: {},\n  variables: {},\n  containers: {},\n  animatedProps: new Set(),\n  transitionProps: new Set(),\n  requiresLayout: false,\n  hasInlineVariables: false,\n  hasInlineContainers: false,\n};\n"]}