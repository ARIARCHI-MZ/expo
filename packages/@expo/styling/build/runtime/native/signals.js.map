{"version":3,"file":"signals.js","sourceRoot":"","sources":["../../../src/runtime/native/signals.ts"],"names":[],"mappings":"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","sourcesContent":["import { useMemo, useEffect, useState } from 'react';\n\nimport { Signal } from '../../types';\n/*\n * This file handles the reactivity of our style.\n * The problem is that styles can conditionally use dynamic units (e.g. rem), and they\n * might not be on the top level, e.g. var(var(var(10rem)))\n * They also might be inside media/container queries and/or never used!\n *\n * Because Signals track their own usage, it means we can keep the complexity in this\n * file and keep the rest of the codebase relatively clean.\n *\n * We are using eager signals with the MobX stale algorithm.\n *\n * This implementation is heavily based on the following resources:\n * - https://dev.to/ryansolid/building-a-reactive-library-from-scratch-1i0p\n * - https://medium.com/hackernoon/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254\n * - https://github.com/fabiospampinato/flimsy\n *\n * Batching is not implemented. Nesting computations is supported but not used.\n */\n\ninterface Computation<T = unknown> {\n  /** The function that is being tracked */\n  fn: () => T;\n  /** The number of dependencies waiting to be resolved */\n  waiting: number;\n  /** Has something actually changed */\n  fresh: boolean;\n  /** Where the result of fn() is stored */\n  signal: Signal<T>;\n  /** Execute fn() in a new context */\n  execute(): void;\n  /**\n   * Get the signal value without subscribing\n   * TODO: Is this needed?\n   */\n  snapshot(): T;\n  /** The subscriptions dependancies */\n  dependencies: Set<Set<Computation | (() => void)>>;\n  /** Manually subscribe to the computation outside of a context */\n  subscribe(callback: () => void): () => void;\n  /** Update the fn() and re-execute */\n  update(fn: () => T): void;\n  /**\n   * Propagating change of the \"stale\" status to every observer of this signal\n   * +1 means a signal you depend on is stale, wait for it\n   * -1 means a signal you depend on just became non-stale, maybe you can update yourself now if you are not waiting for anything else\n   * The \"fresh\" value tells observers whether something actually changed or not\n   * If nothing changed, not for this signal nor for any other signal that a computation is listening to, then the computation will just not be re-executed, for performance\n   * If at least one signal changed the computation will eventually be re-executed\n   */\n  stale(change: 1 | -1, fresh: boolean): void;\n}\n\nconst context: Computation[] = [];\n\n/**\n * Signals make values reactive, as going through function calls to get/set values for them enables the automatic\n * dependency tracking and computation re-execution\n *\n * @typedef T - the value of the signal\n * @returns {Signal<T>} - the signal\n */\nexport function createSignal<T = unknown>(value: T): Signal<T> {\n  const subscriptions = new Set<Computation | (() => void)>();\n\n  const get = () => {\n    const running = context[context.length - 1];\n    if (running) {\n      subscriptions.add(running);\n      running.dependencies.add(subscriptions);\n    }\n    return value;\n  };\n\n  const snapshot = () => value;\n\n  const set = (nextValue: T) => {\n    if (Object.is(value, nextValue)) return;\n\n    value = nextValue;\n\n    stale(1, true);\n    stale(-1, true);\n  };\n\n  const stale = (change: 1 | -1, fresh: boolean): void => {\n    for (const subscriber of [...subscriptions]) {\n      if (typeof subscriber === 'function') {\n        subscriber();\n      } else {\n        subscriber.stale(change, fresh);\n      }\n    }\n  };\n\n  const subscribe = (callback: () => void) => {\n    subscriptions.add(callback);\n    return () => {\n      subscriptions.delete(callback);\n    };\n  };\n\n  return { get, set, stale, subscribe, snapshot };\n}\n\nfunction cleanup(running: Computation) {\n  for (const dep of running.dependencies) {\n    dep.delete(running);\n  }\n  running.dependencies.clear();\n}\n\nfunction createComputation<T = unknown>(fn: () => T) {\n  const computation: Computation<T> = {\n    fn,\n    waiting: 0,\n    fresh: false,\n    signal: createSignal(undefined) as Signal<T>,\n    dependencies: new Set(),\n    snapshot() {\n      return computation.signal.snapshot();\n    },\n    subscribe(callback: () => void) {\n      return this.signal.subscribe(callback);\n    },\n    execute() {\n      cleanup(computation);\n      context.push(computation);\n\n      this.waiting = 0;\n      this.fresh = false;\n\n      this.signal.set(this.fn());\n      context.pop();\n    },\n    update(fn: () => T) {\n      if (fn === this.fn) return;\n      this.fn = fn;\n      this.execute();\n    },\n    stale(change: 1 | -1, fresh: boolean) {\n      if (!this.waiting && change < 0) return;\n\n      if (!this.waiting && change > 0) {\n        this.signal.stale(1, false);\n      }\n\n      this.waiting += change;\n      this.fresh ||= fresh;\n\n      if (!this.waiting) {\n        this.waiting = 0;\n\n        if (this.fresh) {\n          this.execute();\n        }\n\n        this.signal.stale(-1, false);\n      }\n    },\n  };\n\n  computation.execute();\n\n  return computation;\n}\n\n/**\n * Runs a computation function and returns its result.\n * This function also takes an array of dependencies, and will re-run the computation if any of these dependencies have changed.\n * It also takes a callback to rerender the component if the computation result changes.\n *\n * @typeParam T - the return type of the computation function\n * @param {() => T} fn - the computation function to be run\n * @param {unknown[]} dependencies - an array of dependencies that may change the computation result\n * @param {() => void} rerender - a callback to rerender the component if the computation result changes\n * @returns {T} - the result of the computation function\n */\nexport function useComputation<T>(fn: () => T, dependencies: unknown[], rerender: () => void): T {\n  const [computation] = useState(() => createComputation(fn));\n  useMemo(() => computation.update(fn), dependencies);\n  useEffect(() => computation.subscribe(rerender), [computation]);\n  return computation.snapshot();\n}\n"]}