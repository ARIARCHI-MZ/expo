{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type {\n  MediaQuery,\n  Animation,\n  ContainerType,\n  MediaCondition,\n  Time,\n  EasingFunction,\n} from \"lightningcss\";\nimport type {\n  ImageStyle,\n  MatrixTransform,\n  PerpectiveTransform,\n  RotateTransform,\n  RotateXTransform,\n  RotateYTransform,\n  RotateZTransform,\n  ScaleTransform,\n  ScaleXTransform,\n  ScaleYTransform,\n  SkewXTransform,\n  SkewYTransform,\n  TextStyle,\n  TranslateXTransform,\n  TranslateYTransform,\n  ViewStyle,\n} from \"react-native\";\n\nexport type RuntimeValue = {\n  type: \"runtime\";\n  name: string;\n  arguments: any[];\n};\n\nexport type ExtractedStyleValue =\n  | string\n  | number\n  | RuntimeValue\n  | ExtractedStyleValue[];\n\nexport type ExtractedStyle = {\n  isDynamic?: boolean;\n  media?: MediaQuery[];\n  variables?: Record<string, ExtractedStyleValue>;\n  style: Record<string, ExtractedStyleValue>;\n  pseudoClasses?: PseudoClassesQuery;\n  animations?: ExtractedAnimations;\n  container?: Partial<ExtractedContainer>;\n  containerQuery?: ExtractedContainerQuery[];\n  transition?: ExtractedTransition;\n  requiresLayout?: boolean;\n};\n\nexport type InteropMeta = {\n  /* The processed styled props */\n  styledProps: Record<string, Style>;\n  /* The processed styled props */\n  styledPropsMeta: Record<string, PropInteropMeta>;\n  /* Inline variables */\n  variables: Record<string, unknown>;\n  /* Inline container runtime info */\n  containers: Record<string, ContainerRuntime>;\n  /* A list of props that will be processed by useAnimated  */\n  animatedProps: Set<string>;\n  /* A list of props that will be processed by useTransition  */\n  transitionProps: Set<string>;\n  /* Does this component need the onLayout handler  */\n  requiresLayout: boolean;\n  /* Does variables have any values  */\n  hasInlineVariables: boolean;\n  /* Does variables have any values  */\n  hasInlineContainers: boolean;\n  /* If defined, we should wrap in the AnimationInterop */\n  animationInteropKey?: string;\n  /* Should we add press handlers */\n  hasActive?: boolean;\n  /* Should we add hover handlers */\n  hasHover?: boolean;\n  /* Should we add focus handlers */\n  hasFocus?: boolean;\n};\n\nexport type PropInteropMeta = {\n  variables?: Record<string, unknown>;\n  containers?: string[];\n  animated: boolean;\n  transition: boolean;\n  requiresLayout: boolean;\n  hasActive?: boolean;\n  hasHover?: boolean;\n  hasFocus?: boolean;\n};\n\nexport type StyleMeta = {\n  variableProps?: Set<string>;\n  media?: MediaQuery[];\n  variables?: Record<string, unknown>;\n  pseudoClasses?: PseudoClassesQuery;\n  animations?: ExtractedAnimations;\n  container?: ExtractedContainer;\n  containerQuery?: ExtractedContainerQuery[];\n  transition?: ExtractedTransition;\n  requiresLayout?: boolean;\n};\n\nexport interface SignalLike<T = unknown> {\n  get(): T;\n}\n\nexport interface Signal<T = unknown> {\n  get(): T;\n  snapshot(): T;\n  set(value: T): void;\n  stale(change: 1 | -1, fresh: boolean): void;\n  subscribe(callback: () => void): () => void;\n}\n\nexport type Interaction = {\n  active: Signal<boolean>;\n  hover: Signal<boolean>;\n  focus: Signal<boolean>;\n  layout: {\n    width: Signal<number>;\n    height: Signal<number>;\n  };\n};\n\nexport type ExtractedContainer = {\n  names?: string[];\n  type: ContainerType;\n};\n\nexport type ContainerRuntime = {\n  type: ContainerType;\n  interaction: Interaction;\n  style: Style;\n};\n\nexport type ExtractedContainerQuery = {\n  name?: string | null;\n  condition?: MediaCondition;\n  pseudoClasses?: PseudoClassesQuery;\n};\n\nexport type ExtractedAnimations = {\n  [K in keyof Animation]?: Animation[K][];\n};\n\nexport type ExtractedTransition = {\n  /**\n   * The delay before the transition starts.\n   */\n  delay?: Time[];\n  /**\n   * The duration of the transition.\n   */\n  duration?: Time[];\n  /**\n   * The property to transition.\n   */\n  property?: AnimatableCSSProperty[];\n  /**\n   * The easing function for the transition.\n   */\n  timingFunction?: EasingFunction[];\n};\n\nexport type ExtractedAnimation = {\n  frames: ExtractedKeyframe[];\n  requiresLayout?: boolean;\n};\n\nexport type ExtractedKeyframe = {\n  selector: number;\n  style: Record<string, ExtractedStyleValue>;\n};\n\nexport type PseudoClassesQuery = {\n  hover?: boolean;\n  active?: boolean;\n  focus?: boolean;\n};\n\nexport type StyleSheetRegisterOptions = {\n  declarations?: Record<string, ExtractedStyle | ExtractedStyle[]>;\n  keyframes?: Record<string, ExtractedAnimation>;\n};\n\nexport type Style = ViewStyle & TextStyle & ImageStyle;\nexport type StyleProp = Style | StyleProp[] | undefined;\n\nexport type NamedStyles<T> = {\n  [P in keyof T]: StyleProp;\n};\n\nexport type TransformRecord = Partial<\n  PerpectiveTransform &\n    RotateTransform &\n    RotateXTransform &\n    RotateYTransform &\n    RotateZTransform &\n    ScaleTransform &\n    ScaleXTransform &\n    ScaleYTransform &\n    TranslateXTransform &\n    TranslateYTransform &\n    SkewXTransform &\n    SkewYTransform &\n    MatrixTransform\n>;\n\nexport type CamelToKebabCase<\n  T extends string,\n  A extends string = \"\"\n> = T extends `${infer F}${infer R}`\n  ? CamelToKebabCase<\n      R,\n      `${A}${F extends Lowercase<F> ? \"\" : \"-\"}${Lowercase<F>}`\n    >\n  : A;\n\nexport type KebabToCamelCase<S extends string> =\n  S extends `${infer P1}-${infer P2}${infer P3}`\n    ? `${Lowercase<P1>}${Uppercase<P2>}${KebabToCamelCase<P3>}`\n    : Lowercase<S>;\n\n/*\n * This is a list of all the CSS properties that can be animated\n * Source: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties\n */\nexport type AnimatableCSSProperty = keyof Style &\n  KebabToCamelCase<\n    | \"background-color\"\n    | \"border-bottom-color\"\n    | \"border-bottom-left-radius\"\n    | \"border-bottom-right-radius\"\n    | \"border-bottom-width\"\n    | \"border-color\"\n    | \"border-left-color\"\n    | \"border-left-width\"\n    | \"border-radius\"\n    | \"border-right-color\"\n    | \"border-right-width\"\n    | \"border-top-color\"\n    | \"border-top-width\"\n    | \"border-width\"\n    | \"bottom\"\n    | \"color\"\n    | \"flex\"\n    | \"flex-basis\"\n    | \"flex-grow\"\n    | \"flex-shrink\"\n    | \"font-size\"\n    | \"font-weight\"\n    | \"gap\"\n    | \"height\"\n    | \"left\"\n    | \"letter-spacing\"\n    | \"line-height\"\n    | \"margin\"\n    | \"margin-bottom\"\n    | \"margin-left\"\n    | \"margin-right\"\n    | \"margin-top\"\n    | \"max-height\"\n    | \"max-width\"\n    | \"min-height\"\n    | \"min-width\"\n    | \"object-position\"\n    | \"opacity\"\n    | \"order\"\n    | \"padding\"\n    | \"padding-bottom\"\n    | \"padding-left\"\n    | \"padding-right\"\n    | \"padding-top\"\n    | \"right\"\n    | \"rotate\"\n    | \"scale\"\n    | \"text-decoration\"\n    | \"top\"\n    | \"transform\"\n    | \"transform-origin\"\n    | \"translate\"\n    | \"vertical-align\"\n    | \"visibility\"\n    | \"width\"\n    | \"word-spacing\"\n    | \"z-index\"\n  >;\n"]}