{"version":3,"file":"basic.js","sourceRoot":"","sources":["../../../src/__typetests__/fixtures/basic.ts"],"names":[],"mappings":";AAAA,sDAAsD","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n\n  import type { ReactNode } from 'react';\n  import type { TextProps, GestureResponderEvent } from 'react-native';\n\n  type StaticRoutes = `/apple` | `/banana`;\n  type DynamicRoutes<T extends string> = `/colors/${SingleRoutePart<T>}` | `/animals/${CatchAllRoutePart<T>}` | `/mix/${SingleRoutePart<T>}/${SingleRoutePart<T>}/${CatchAllRoutePart<T>}`;\n  type DynamicRouteTemplate = `/colors/[color]` | `/animals/[...animal]` | `/mix/[fruit]/[color]/[...animals]`;\n\n  export type RelativePathString = `./${string}` | `../${string}` | '..';\n  export type AbsoluteRoute = DynamicRouteTemplate | StaticRoutes;\n  export type ExternalPathString = `${string}:${string}`;\n  export type ExpoRouterRoutes = DynamicRouteTemplate | StaticRoutes | RelativePathString;\n  export type AllRoutes = ExpoRouterRoutes | ExternalPathString;\n\n  /****************\n   * Route Utils  *\n   ****************/\n  type SearchOrHash = `?${string}` | `#${string}`;\n  type UnknownInputParams = Record<string, string | number | (string | number)[]>;\n  type UnknownOutputParams = Record<string, string | string[]>;\n\n  /**\n   * Return only the RoutePart of a string. If the string has multiple parts return never\n   *\n   * string   | type\n   * ---------|------\n   * 123      | 123\n   * /123/abc | never\n   * 123?abc  | never\n   * ./123    | never\n   * /123     | never\n   * 123/../  | never\n   */\n  type SingleRoutePart<S extends string> = S extends `${string}/${string}`\n    ? never\n    : S extends `${string}${SearchOrHash}`\n    ? never\n    : S extends ''\n    ? never\n    : S extends `(${string})`\n    ? never\n    : S extends `[${string}]`\n    ? never\n    : S;\n\n  /**\n   * Return only the CatchAll router part. If the string has search parameters or a hash return never\n   */\n  type CatchAllRoutePart<S extends string> = S extends `${string}${SearchOrHash}`\n    ? never\n    : S extends ''\n    ? never\n    : S extends `${string}(${string})${string}`\n    ? never\n    : S extends `${string}[${string}]${string}`\n    ? never\n    : S;\n\n  /**\n   * Return the name of a route parameter\n   * '[test]'    -> 'test'\n   * 'test'      -> never\n   * '[...test]' -> '...test'\n   */\n  type IsParameter<Part> = Part extends `[${infer ParamName}]` ? ParamName : never;\n\n  /**\n   * Return a union of all parameter names. If there are no names return never\n   *\n   * /[test]         -> 'test'\n   * /[abc]/[...def] -> 'abc'|'...def'\n   */\n  type ParameterNames<Path> = Path extends `${infer PartA}/${infer PartB}`\n    ? IsParameter<PartA> | ParameterNames<PartB>\n    : IsParameter<Path>;\n\n  /**\n   * Returns all segments of a route.\n   *\n   * /(group)/123/abc/[id]/[...rest] -> ['(group)', '123', 'abc', '[id]', '[...rest]'\n   */\n  type RouteSegments<Path> = Path extends `${infer PartA}/${infer PartB}`\n    ? PartA extends '' | '.'\n      ? [...RouteSegments<PartB>]\n      : [PartA, ...RouteSegments<PartB>]\n    : Path extends ''\n    ? []\n    : [Path];\n\n  /**\n   * Returns a Record of the routes parameters as strings and CatchAll parameters\n   *\n   * There are two versions, input and output, as you can input 'string | number' but\n   *  the output will always be 'string'\n   *\n   * /[id]/[...rest] -> { id: string, rest: string[] }\n   * /no-params      -> {}\n   */\n  type InputRouteParams<Path> = {\n    [Key in ParameterNames<Path> as Key extends `...${infer Name}`\n      ? Name\n      : Key]: Key extends `...${string}` ? (string | number)[] : string | number;\n  } & UnknownInputParams;\n\n  type OutputRouteParams<Path> = {\n    [Key in ParameterNames<Path> as Key extends `...${infer Name}`\n      ? Name\n      : Key]: Key extends `...${string}` ? string[] : string;\n  } & UnknownOutputParams;\n\n  /**\n   * Returns the search parameters for a route.\n   */\n  export type SearchParams<T extends AllRoutes> = T extends DynamicRouteTemplate\n    ? OutputRouteParams<T>\n    : T extends StaticRoutes\n    ? never\n    : UnknownOutputParams;\n\n  /**\n   * Route is mostly used as part of Href to ensure that a valid route is provided\n   *\n   * Given a dynamic route, this will return never. This is helpful for conditional logic\n   *\n   * /test         -> /test, /test2, etc\n   * /test/[abc]   -> never\n   * /test/resolve -> /test, /test2, etc\n   *\n   * Note that if we provide a value for [abc] then the route is allowed\n   *\n   * This is named Route to prevent confusion, as users they will often see it in tooltips\n   */\n  export type Route<T> = T extends string\n    ? T extends DynamicRouteTemplate\n      ? never\n      :\n          | StaticRoutes\n          | RelativePathString\n          | ExternalPathString\n          | (T extends `${infer P}${SearchOrHash}`\n              ? P extends DynamicRoutes<infer _>\n                ? T\n                : never\n              : T extends DynamicRoutes<infer _>\n              ? T\n              : never)\n    : never;\n\n  /*********\n   * Href  *\n   *********/\n\n  export type Href<T = string> = T extends object ? HrefObject<T> : Route<T>;\n\n  export type HrefObject<\n    R extends object,\n    P = R extends { pathname: string } ? R['pathname'] : null,\n  > = P extends DynamicRouteTemplate\n    ? { pathname: P; params: InputRouteParams<P> }\n    : P extends Route<P>\n    ? {\n        pathname: Route<P> | DynamicRouteTemplate;\n        params?: never | InputRouteParams<P>;\n      }\n    : { pathname: DynamicRouteTemplate };\n\n  /***********************\n   * Expo Router Exports *\n   ***********************/\n\n  export type Router = {\n    /** Go back in the history. */\n    back: () => void;\n    /** If there's history that supports invoking the `back` function. */\n    canGoBack: () => boolean;\n    /** Navigate to the provided href. */\n    push: <T>(href: Href<T>) => void;\n    /** Navigate to route without appending to the history. */\n    replace: <T>(href: Href<T>) => void;\n    /** Update the current route query params. */\n    setParams: <T = ''>(\n      params?: T extends '' ? Record<string, string> : InputRouteParams<T>\n    ) => void;\n  };\n\n  /** The imperative router. */\n  export declare const router: Router;\n\n  /************\n   * <Link /> *\n   ************/\n  export interface WebAnchorProps {\n    /**\n     * **Web only:** Specifies where to open the `href`.\n     *\n     * - **_self**: the current tab.\n     * - **_blank**: opens in a new tab or window.\n     * - **_parent**: opens in the parent browsing context. If no parent, defaults to **_self**.\n     * - **_top**: opens in the highest browsing context ancestor. If no ancestors, defaults to **_self**.\n     *\n     * This property is passed to the underlying anchor (`<a>`) tag.\n     *\n     * @default '_self'\n     *\n     * @example\n     * <Link href=\"https://expo.dev\" target=\"_blank\">Go to Expo in new tab</Link>\n     */\n    target?: '_self' | '_blank' | '_parent' | '_top' | (string & object);\n\n    /**\n     * **Web only:** Specifies the relationship between the `href` and the current route.\n     *\n     * Common values:\n     * - **nofollow**: Indicates to search engines that they should not follow the `href`. This is often used for user-generated content or links that should not influence search engine rankings.\n     * - **noopener**: Suggests that the `href` should not have access to the opening window's `window.opener` object, which is a security measure to prevent potentially harmful behavior in cases of links that open new tabs or windows.\n     * - **noreferrer**: Requests that the browser not send the `Referer` HTTP header when navigating to the `href`. This can enhance user privacy.\n     *\n     * The `rel` property is primarily used for informational and instructive purposes, helping browsers and web\n     * crawlers make better decisions about how to handle and interpret the links on a web page. It is important\n     * to use appropriate `rel` values to ensure that links behave as intended and adhere to best practices for web\n     * development and SEO (Search Engine Optimization).\n     *\n     * This property is passed to the underlying anchor (`<a>`) tag.\n     *\n     * @example\n     * <Link href=\"https://expo.dev\" rel=\"nofollow\">Go to Expo</Link>\n     */\n    rel?: string;\n\n    /**\n     * **Web only:** Specifies that the `href` should be downloaded when the user clicks on the link,\n     * instead of navigating to it. It is typically used for links that point to files that the user should download,\n     * such as PDFs, images, documents, etc.\n     *\n     * The value of the `download` property, which represents the filename for the downloaded file.\n     * This property is passed to the underlying anchor (`<a>`) tag.\n     *\n     * @example\n     * <Link href=\"/image.jpg\" download=\"my-image.jpg\">Download image</Link>\n     */\n    download?: string;\n  }\n\n  export interface LinkProps<T> extends Omit<TextProps, 'href'>, WebAnchorProps {\n    /** Path to route to. */\n    href: Href<T>;\n\n    // TODO(EvanBacon): This may need to be extracted for React Native style support.\n    /** Forward props to child component. Useful for custom buttons. */\n    asChild?: boolean;\n\n    /** Should replace the current route without adding to the history. */\n    replace?: boolean;\n\n    /** On web, this sets the HTML `class` directly. On native, this can be used with CSS interop tools like Nativewind. */\n    className?: string;\n\n    onPress?: (e: React.MouseEvent<HTMLAnchorElement, MouseEvent> | GestureResponderEvent) => void;\n  }\n\n  export interface LinkComponent {\n    <T>(props: React.PropsWithChildren<LinkProps<T>>): JSX.Element;\n    /** Helper method to resolve an Href object into a string. */\n    resolveHref: <T>(href: Href<T>) => string;\n  }\n\n  /**\n   * Component to render link to another route using a path.\n   * Uses an anchor tag on the web.\n   *\n   * @param props.href Absolute path to route (e.g. \\`/feeds/hot\\`).\n   * @param props.replace Should replace the current route without adding to the history.\n   * @param props.asChild Forward props to child component. Useful for custom buttons.\n   * @param props.children Child elements to render the content.\n   * @param props.className On web, this sets the HTML \\`class\\` directly. On native, this can be used with CSS interop tools like Nativewind.\n   */\n  export declare const Link: LinkComponent;\n\n  /** Redirects to the href as soon as the component is mounted. */\n  export declare const Redirect: <T>(props: React.PropsWithChildren<{ href: Href<T> }>) => ReactNode;\n\n  /**\n   * Hooks\n   */\n\n  export declare function useRouter(): Router;\n  type useRouter = typeof useRouter;\n\n  /**\n   * Returns the URL search parameters for the contextually focused route. e.g. \\`/acme?foo=bar\\` -> \\`{ foo: \"bar\" }\\`.\n   * This is useful for stacks where you may push a new screen that changes the query parameters.\n   *\n   * To observe updates even when the invoking route is not focused, use \\`useGlobalSearchParams()\\`.\n   * @see \\`useGlobalSearchParams\\`\n   */\n  export declare function useLocalSearchParams<\n    TParams extends AllRoutes | UnknownOutputParams = UnknownOutputParams,\n  >(): TParams extends AllRoutes ? SearchParams<TParams> : TParams;\n  type useLocalSearchParams = typeof useLocalSearchParams;\n\n  /**\n   * Get the globally selected query parameters, including dynamic path segments. This function will update even when the route is not focused.\n   * Useful for analytics or other background operations that don't draw to the screen.\n   *\n   * When querying search params in a stack, opt-towards using \\`useLocalSearchParams\\` as these will only\n   * update when the route is focused.\n   *\n   * @see \\`useLocalSearchParams\\`\n   */\n  export declare function useGlobalSearchParams<\n    T extends AllRoutes | UnknownOutputParams = UnknownOutputParams,\n  >(): T extends AllRoutes ? SearchParams<T> : T;\n  type useGlobalSearchParams = typeof useGlobalSearchParams;\n\n  /**\n   * Get a list of selected file segments for the currently selected route. Segments are not normalized, so they will be the same as the file path. e.g. /[id]?id=normal -> [\"[id]\"]\n   *\n   * \\`useSegments\\` can be typed using an abstract.\n   * Consider the following file structure, and strictly typed \\`useSegments\\` function:\n   *\n   * \\`\\`\\`md\n   * - app\n   *   - [user]\n   *     - index.js\n   *     - followers.js\n   *   - settings.js\n   * \\`\\`\\`\n   * This can be strictly typed using the following abstract:\n   *\n   * \\`\\`\\`ts\n   * const [first, second] = useSegments<['settings'] | ['[user]'] | ['[user]', 'followers']>()\n   * \\`\\`\\`\n   */\n  export declare function useSegments<\n    T extends AbsoluteRoute | RouteSegments<AbsoluteRoute> | RelativePathString,\n  >(): T extends AbsoluteRoute ? RouteSegments<T> : T extends string ? string[] : T;\n  type useSegments = typeof useSegments;\n"]}